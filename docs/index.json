[
{
	"uri": "/_header/",
	"title": "Header",
	"tags": [],
	"description": "",
	"content": "Claudia Vitolo&amp;rsquo;s personal website "
},
{
	"uri": "/",
	"title": "Index",
	"tags": [],
	"description": "",
	"content": "Welcome to my website! Ciao! I&amp;rsquo;m Claudia, a Scientist working on natural hazard risk modelling at ECMWF. In this website you can find out about my background and experience (in the About me section), what I work on (in the Projects section), what I&amp;rsquo;m curious about (in the Blog section) and what I like to talk about (in the Talks section). Buona lettura! @clavitolo &amp;emsp; @cvitolo &amp;emsp; Google Scholar "
},
{
	"uri": "/2017/05/01/migrating-from-wordpress-to-hugo/",
	"title": "Migrating from WordPress to HUGO",
	"tags": [],
	"description": "",
	"content": "Few years ago I started blogging, mainly to collect notes and interesting experiments for my PhD. I used wordpress and I found it very convenient at that time. Nowdays, using R for just about everything, I could not resist to the temptation of making my own blog using blogdown and HUGO. However I did not want to maintain two blogs so I had to: export my wordpress content convert this content to markdown set up a hugo blog Export wordpress content I started googling &amp;lsquo;how to migrate from wordpress to markdown&amp;rsquo;. I found out that it is possible to export the entire wordpress blog (in xml format) using the exporter tool in the wordpress admin dashboard. Just log in to your wordpress -&amp;gt; My Sites -&amp;gt; Settings -&amp;gt; Export -&amp;gt; click on the button &amp;lsquo;Export all&amp;rsquo;. Let&amp;rsquo;s call the downloaded file wp.xml Convert wordpress content to markdown Amongst the various options I decided to use for exitwp, it is a simple and very efficient solution to convert the xml file to a series of markdown files. I cloned the githup repository locally, pasted the wp.xml file in the exitwp/wordpress-xml directory, and run Set up a hugo blog I have built this website using blogdowm and the docdock theme for HUGO. "
},
{
	"uri": "/talk/2017-04-26-rladies_blog/",
	"title": "Make your own blog",
	"tags": [],
	"description": "",
	"content": "On 26th April 2017 I ran a workshop on &amp;ldquo;Making your own blog&amp;rdquo; for one of the community events organised by R-Ladies London (London, United Kingdom). All the attendees were very interested and participative, it was a great evening! Slides are available here. For more information visit the R-Ladies website. "
},
{
	"uri": "/talk/2017-03-22-bul/",
	"title": "Analysis of geospatial data using R",
	"tags": [],
	"description": "",
	"content": "On the 22nd March 2017 Julia Wagemann and I gave a guest lecture/workshop on the topic &amp;ldquo;Analysis of geospatial data using R&amp;rdquo; for the MSc module on &amp;ldquo;GIS and Data Analysis&amp;rdquo; at the Institute of Environment, Health and Societies, Department of Life Sciences of Brunel University London (Uxbridge, United Kingdom). We covered the following topics: Intro to Data Science @ECMWF The air pollution challenge Geospatial data selection, validation, aggregation, visualisation and publication. "
},
{
	"uri": "/talk/2017-02-03-winds/",
	"title": "Data Science @ECMWF",
	"tags": [],
	"description": "",
	"content": "On 3rd February 2017 I was invited to talk on doing Data Science for the European Centre for Medium-range Weather Forecast for the Reading (United Kingdom) chapter of the Women in Data Science conference 2017. Slides are available here. "
},
{
	"uri": "/project/anywhere/",
	"title": "ANYWHERE",
	"tags": [],
	"description": "",
	"content": "EnhANcing emergencY management and response to extreme WeatHER and climate Events (ANYWHERE) is funded within EUâ€™s Horizon 2020 research and innovation programme (EC-HORIZON2020-PR700099-ANYWHERE). The challenge: Development of tools to support realtime coordination of the emergency response operations to face challenge of the extreme weather and climate events. Objectives: Employ the cutting edge innovative technologies to build a pan-europeans multi-hazard platform for faster analysis and anticipation of the risk prior the vent occurrence, improved coordination of the emergency actions and assist to raise the self-preparedness. Impacts: More effective early warning systems and decision support systems, accompanied by tailored online services developed to support self-preparedness, self-protection, and self-response of citizens. Advanced technological innovations to Civil Protection, first responders and emergency authorities supporting them in faster and more effective responses to W&amp;amp;C disasters and emergencies. More info here: http://anywhere-h2020.eu/ "
},
{
	"uri": "/about/",
	"title": "About me",
	"tags": [],
	"description": "",
	"content": "My name is Claudia Vitolo, I&amp;rsquo;m Italian and I work as Scientist at the European Centre for Medium-range Weather Forecasts (ECMWF, Reading, United Kingdom) on natural hazard risk modelling. My work consists of developing tools and algorithms to facilitate the retrieval, modelling and visualisation of environmental data. I&amp;rsquo;m passionate about open knowledge/data/source projects and addicted to R (the statistical language). In my spare time I like to participate to hackatons, coding do-jos and I organise meetups in the data science field. I&amp;rsquo;m co-founder of the R-Ladies, a world-wide organization to promote gender diversity in the R community. Here is my curriculum vitae. Follow me on: &amp;emsp; @clavitolo &amp;emsp; @cvitolo &amp;emsp; Google Scholar "
},
{
	"uri": "/talk/2016-02-12-kcl/",
	"title": "Why and how open data and open APIs can improve research",
	"tags": [],
	"description": "",
	"content": "On 12th February 2016 I was invited to give a talk on &amp;ldquo;Why and how open data and open APIs can improve research&amp;rdquo; for the Environmental Dynamics research group seminar series is organised at the Department of Geography of King&amp;rsquo;s College London (London, United Kingdom). The audience was made of students, researchers and academics, all interested and participative, which made the experience rather enjoyable for me. More information on this series of seminars is on the King&amp;rsquo;s geocomputation blog. I presented work done for my PhD and the PURE project. During my seminar I showed how to assemble data requests using the National River Flow Archive&amp;rsquo;s RESTful APIs, how to parse and convert server responses using the R language and the rnrfa package. Slides are available here. I also presented a demo (code and examples are taken from this paper). "
},
{
	"uri": "/project/community/",
	"title": "Community",
	"tags": [],
	"description": "",
	"content": "In my spare time I like to participate to hackatons, coding do-jos and I organise meetups in the data science field. Here is a list of community events I have contributed to: R-Ladies (co-founder), a world-wide organization to promote gender diversity in the R community. R-Ladies London (co-organiser), the London chapter is very active with regular (~monthly) meetups are socials. More info on the R-Ladies London meetup page. Open Data Hack @ECMWF (co-organiser), the event was part of ECMWF&amp;rsquo;s Open Data Week and aimed to raise awareness of freely available data from ECMWF and the three Copernicus services Copernicus Climate Change Service (C3S), Copernicus Atmosphere Monitoring Service (CAMS) and Copernicus Emergency Management Service (CEMS). Data Science in Reading (co-organised the event related to the &amp;lsquo;Women in Data Science conference 2017&amp;rsquo;). "
},
{
	"uri": "/project/open/",
	"title": "Open source/data repos",
	"tags": [],
	"description": "",
	"content": "I&amp;rsquo;m very passionate about open knowledge/data/source projects, most of my work is available from public repositories on GitHub. Here are (some of) my repositories: rnrfa fuse cvitolo.github.io (the source code for this website). caliver, hosted on the ECMWF organisation. rdefra, hosted on the rOpenSci organisation. hddtools, hosted on the rOpenSci organisation. kehra, hosted on KehraProject, Brunel University London. kehraApp, hosted on KehraProject, Brunel University London. Work-in-progress: amca curvenumber r_pure BigDataAnalytics Here is the list of organisations I have contributed to: R-Ladies R-Ladies London rOpenSci OpenDataHack DataScienceReading "
},
{
	"uri": "/project/phd/",
	"title": "Ph.D.",
	"tags": [],
	"description": "",
	"content": "Between 2011 and 2015 I did a PhD in hydrology at Imperial College London (London, United Kingdom). My thesis is on Exploring Data Mining for Hydrological Modelling and it is available here. "
},
{
	"uri": "/talk/2015-11-18-rss/",
	"title": "Improving access to geospatial Big Data in the hydrology domain",
	"tags": [],
	"description": "",
	"content": "On 18th November 2015 I gave a talk on &amp;ldquo;Improving access to geospatial Big Data in the hydrology domain&amp;rdquo; for the &amp;ldquo;Big Data and Spatial Analytics&amp;rdquo; event organised by the Business and Industrial Section of the Royal Statistical Society (London, United Kingdom). It was a great opportunity to meet people interested in Big Data and geospatial analytics. I presented some of the work done for my PhD and the PURE project. Slides are available here. I also presented a demo (the code is available here). "
},
{
	"uri": "/2015/05/26/fuse-model-and-parameters-information/",
	"title": "FUSE model and parameters information",
	"tags": [],
	"description": "",
	"content": "A quick post to show how to find what model building decisions, options (name and ID number) and depending parameters are associated with a given FUSE model. First of all, install/load the fuse package: devtools::install_github(&amp;quot;cvitolo/fuse&amp;quot;) library(fuse) Choose one of FUSE&amp;rsquo;s models (e.g. TOPMODEL which corresponds to mid = 60)and run the function fuseInfo using mid as input: fuseInfo(mid = 60) The result of FUSEinfo is a dataframe containing 32 columns. rferr arch1 arch2 qsurf qperc esoil qintf q_tdh rferr_add rferr_mlt maxwatr_1 maxwatr_2 fracten 1 12 21 34 43 51 62 71 82 FALSE TRUE TRUE TRUE TRUE frchzne fprimqb rtfrac1 percrte percexp sacpmlt sacpexp percfrac iflwrte baserte qb_powr qb_prms 1 FALSE FALSE FALSE TRUE TRUE FALSE FALSE FALSE FALSE TRUE TRUE FALSE qbrate_2a qbrate_2b sareamax axv_bexp loglamb tishape timedelay 1 FALSE FALSE FALSE FALSE TRUE TRUE TRUE The first 8 columns contain the model building decisions: rferr (rainfall error), arch1 (upper soil layer), arch2 (lower soil layer), qsurf (runoff mechanism), qperc (percolation), esoil (evaporation), qintfl (interflow) and q_tdh (routing). See the table below for more information: The remaining 24 columns list the parameters (see table below). If the value of a parameter is TRUE, it means that parameter is used by the model, FALSE means the parameter is not used. "
},
{
	"uri": "/2015/05/26/generate-a-latin-hypercube-of-parameters-for-a-given-fuse-model/",
	"title": "Generate a Latin Hypercube of parameters for a given FUSE model",
	"tags": [],
	"description": "",
	"content": "In the previous post I showed how to get information regarding model building options and used parameters for a given FUSE model. In this post I&amp;rsquo;ll show how to sample (for the given model) a set of 100 parameters uniformly using the Latin Hypercube Sampling method. Each FUSE model uses different parameters therefore, in order to sample uniformly, we need to remove the unused parameters and then sample. Here is how I achieve this. Install/load the fuse package: devtools::install_github(&amp;quot;cvitolo/fuse&amp;quot;) library(fuse) Choose one of FUSE&amp;rsquo;s models (e.g. TOPMODEL which corresponds to mid = 60) and get model/parameters info using the FUSEinfo function described in the previous post: x &amp;lt;- fuseInfo(mid = 60) Now a Latin Hypercube of 100 samples for the above model (mid=60) is defined as follows: parameters &amp;lt;- generateParameters(NumberOfRuns = 100, params2remove = names(x)[which(x==FALSE)]) "
},
{
	"uri": "/2015/05/11/the-textinfooter-macro/",
	"title": "The TextInFooter macro",
	"tags": [],
	"description": "",
	"content": "This post is for my friend Sue and all the people that use Microsoft Word and want to add to the footer of their documents a reminder to the file location and the timestamp when the document was last saved. This can be achieved using a small VBA macro, and here is how to do it. Copy the content in the box below Sub FileSaveAs() Dialogs(wdDialogFileSaveAs).Show Dim i As Long Dim ThisPath As String Dim pName As String Dim TextInFooter As String Dim FullName As String ThisPath = ActiveDocument.Path pName = ActiveDocument.Name FullName = ThisPath &amp;amp; &amp;quot;\&amp;quot; &amp;amp; pName TextInFooter = &amp;quot;This file was saved in: &amp;quot; &amp;amp; FullName &amp;amp; &amp;quot; on the &amp;quot; &amp;amp; Now For i = 1 To ActiveDocument.Sections.Count With ActiveDocument.Sections(i) .Footers(wdHeaderFooterPrimary).Range.Text = TextInFooter End With Next End Sub To save the macro: Open an existing word document, then press ALT+F11. Right-Click on Normal in the file explorer in the left hand side panel. Click on INSERT, then click on MODULE. Copy the text at the bottom of this email and paste it in the empty window that opens on the top-right panel. Click on SaveNormal. If you want to save a document without changing the footer, you either press the save button or CTRL+S. These will not run the macro. If you want to save a document with path+date&amp;amp;time in the footer, you either press FILE -&amp;gt; SaveAs button or F12. These will run the macro. Remember, you have to save the macro only once. After that, the macro will work on any new or existing document on your computer. However if you change computer or reset it, you will need to re-save the macro. "
},
{
	"uri": "/2014/11/30/split-long-time-series-into-hydrological-years-in-r/",
	"title": "Split long time series into (hydrological) years in R",
	"tags": [],
	"description": "",
	"content": "I have been recently working on a rather basic task: splitting long time series into years. Although this might sound trivial for calendar years, I had to think a bit to find a relatively elegant solution for hydrological years. Below is what I came up with, however if you are aware of a better way, please leave a comment! For this exercise, we need to load only one library: # Load library library(xts) Let&amp;rsquo;s generate a dummy time series: # Generate dummy time series from &amp;lt;- as.Date(&amp;quot;1950-01-01&amp;quot;) to &amp;lt;- as.Date(&amp;quot;1990-12-31&amp;quot;) myDates &amp;lt;- seq.Date(from=from,to=to,by=&amp;quot;day&amp;quot;) myTS &amp;lt;- as.xts(runif(length(myDates)),order.by=myDates) When working with standard calendar years (from Jan to Dec), splitting a time series into years is not too much of a problem: # Split the time series into calendar years myList &amp;lt;- tapply(myTS, format(myDates, &amp;quot;%Y&amp;quot;), c) The result is a list of 41 time series, each of lenght = 1 year. Any time series can be accessed, as usual, via its index: myList[[1]] plot( myList[[1]] ) Things become more interesting with non-standard calendars, such as hydrological years (starting on the 1st October and ending on the following 30th September). The first step is to calculate the number of hydrological years, this is going to be: the number of years in which we have records from Jan (index = 0) to September (index = 8) minus 1 (because we cannot count the first year). # calculate the number of hydrological years nHY &amp;lt;- length(split(myTS[.indexmon(myTS) %in% 0:8], f=&amp;quot;years&amp;quot;))-1 Then we create an empty list and populate it with a series in which we append (or bind) the records from October to December of a generic year counter&#39;&#39;, to the records from Jan to Sep of the yearcounter+1&amp;rdquo;. # create an empty table , to be populate by a loop myList &amp;lt;- list() for ( counter in 1:nHY ){ oct2dec &amp;lt;- split(myTS[.indexmon(myTS) %in% 9:11], f=&amp;quot;years&amp;quot;)[[counter]] jan2sep &amp;lt;- split(myTS[.indexmon(myTS) %in% 0:8], f=&amp;quot;years&amp;quot;)[[counter + 1]] myList[[counter]] &amp;lt;- rbind(oct2dec, jan2sep) } Again, any time series can be accessed via its index: myList[[1]] plot( myList[[1]] ) That&amp;rsquo;s all! The code in this post is also available as public gist. "
},
{
	"uri": "/2014/07/30/the-new-hddtools-an-r-package-for-hydrological-data-discovery/",
	"title": "The new hddtools, an R package for Hydrological Data Discovery",
	"tags": [],
	"description": "",
	"content": "The R package hddtools is an open source project designed to facilitate non programmatic access to on-line data sources. This typically implies the download of a metadata catalogue, selection of information needed, formal request for dataset(s), de-compression, conversion, manual filtering and parsing. All those operation are made more efficient by re-usable functions. Depending on the data license, functions can provide offline and/or on-line modes. When redistribution is allowed, for instance, a copy of the dataset is cached within the package and updated twice a year. This is the fastest option and also allows offline use of package&amp;rsquo;s functions. When re-distribution is not allowed, only on-line mode is provided. The package hddtools can be installed via devtools: library(devtools) install_github(&amp;quot;r_hddtools&amp;quot;, username = &amp;quot;cvitolo&amp;quot;, subdir = &amp;quot;hddtools&amp;quot;) library(hddtools) Data sources and Functions The Koppen Climate Classification map The Koppen Climate Classification is the most widely used system for classifying the world&amp;rsquo;s climates. Its categories are based on the annual and monthly averages of temperature and precipitation. It was first updated by Rudolf Geiger in 1961, then by Kottek et al. (2006), Peel et al. (2007) and then by Rubel et al. (2010). The package hddtools contains a function to identify the updated Koppen-Greiger climate zone, given a bounding box. Extract climate zones from Peel&amp;rsquo;s map: kgclimateclass(BBlonMin=-3.82,BBlonMax=-3.63,BBlatMin=52.41,BBlatMax=52.52,updatedBy=&amp;ldquo;Peel&amp;rdquo;) Extract climate zones from Kottek&amp;rsquo;s map: kgclimateclass(BBlonMin=-3.82,BBlonMax=-3.63,BBlatMin=52.41,BBlatMax=52.52,updatedBy=&amp;ldquo;Kottek&amp;rdquo;) The Global Runoff Data Centre The Global Runoff Data Centre (GRDC) is an international archive hosted by the Federal Institute of Hydrology (Bundesanstalt fÃ¼r GewÃ¤sserkunde or BfG) in Koblenz, Germany. The Centre operates under the auspices of the World Meteorological Organisation and retains services and datasets for all the major rivers in the world. Catalogue, kml files and the product ``Long-Term Mean Monthly Discharges&amp;rdquo; are open data and accessible via the hddtools. # 1. GRDC full catalogue grdcCatalogue() # 2. Filter GRDC catalogue based on a bounding box grdcCatalogue(BBlonMin = -3.82, BBlonMax = -3.63, BBlatMin = 52.43, BBlatMax = 52.52, mdDescription = TRUE) # 3. Monthly data extraction grdcMonthlyTS(1107700,liveData=FALSE) The Data60UK dataset In the decade 2003-2012, the IAHS Predictions in Ungauged Basins (PUB) international Top-Down modelling Working Group (TDWG) collated daily datasets of areal precipitation and streamflow discharge across 61 gauging sites in England and Wales. The database was prepared from source databases for research purposes, with the intention to make it re-usable. This is now available in the public domain free of charge. The hddtools contain two functions to interact with this database: one to retreive the catalogue and another to retrieve time series of areal precipitation and streamflow discharge. # 1a. Data60UK full catalogue data60UKCatalogue() # 1.b Filter Data60UK catalogue based on bounding box data60UKCatalogue(BBlonMin = -3.82, BBlonMax = -3.63, BBlatMin = 52.43, BBlatMax = 52.52) # 2. Extract time series data60UKDailyTS(62001) NASA&amp;rsquo;s Tropical Rainfall Measuring Mission (TRMM) The Tropical Rainfall Measuring Mission (TRMM) is a joint mission between NASA and the Japan Aerospace Exploration Agency (JAXA) that uses a research satellite to measure precipitation within the tropics in order to improve our understanding of climate and its variability. The TRMM satellite records global historical rainfall estimation in a gridded format since 1998 with a daily temporal resolution and a spatial resolution of 0.25 degrees. This information is openly available for educational purposes and downloadable from an FTP server. HDDTOOLS provides a function, called trmm, to download and convert a selected portion of the TRMM dataset into a raster-brick that can be opened in any GIS software. This function is a slight modification of the code published on Martin Brandt&amp;rsquo;s post (thanks Martin!). ``` Generate multi-layer GeoTiff containing mean monthly precipitations from 3B43_V7 for 2012 (based on a bounding box) trmm(fileLocation=&amp;rdquo;~/&amp;ldquo;, url=&amp;ldquo;ftp://disc2.nascom.nasa.gov/data/TRMM/Gridded/&amp;quot;, product=&amp;ldquo;3B43&amp;rdquo;, version=7, year=2012, BBlonMin=-3.82, BBlonMax=-3.63, BBlatMin=52.43, BBlatMax=52.52) Please leave your feedback I would greatly appreciate if you could leave your feedbacks either via email (cvitolodev@gmail.com) or taking a short survey (https://www.surveymonkey.com/s/QQ568FT). Image credits to cilipmarketing: http://goo.gl/Mw2yhC "
},
{
	"uri": "/2014/07/29/the-new-fuse-implementation-is-now-145-times-faster/",
	"title": "The new FUSE implementation is now 145 times faster!",
	"tags": [],
	"description": "",
	"content": "Four of my previous posts were about the fuse implementation in RHydro. Since I published them I received many emails and requests for more info. It is clear the topic is of interest for many. I thought I would post a short note on a new FUSE implementation which is now available as a separate package called &amp;ldquo;fuse&amp;rdquo; on GitHub. # install/load dependent libraries if&amp;lt;/span&amp;gt;(&amp;lt;span class=&amp;quot;pl-k&amp;quot;&amp;gt;!&amp;lt;/span&amp;gt;require(&amp;lt;span class=&amp;quot;pl-vo&amp;quot;&amp;gt;zoo&amp;lt;/span&amp;gt;)) install.packages(&amp;lt;span class=&amp;quot;pl-s1&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;pl-pds&amp;quot;&amp;gt;&amp;quot;&amp;lt;/span&amp;gt;zoo&amp;lt;span class=&amp;quot;pl-pds&amp;quot;&amp;gt;&amp;quot;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;) library(&amp;lt;span class=&amp;quot;pl-vo&amp;quot;&amp;gt;zoo&amp;lt;/span&amp;gt;) &amp;lt;span class=&amp;quot;pl-k&amp;quot;&amp;gt;if&amp;lt;/span&amp;gt;(&amp;lt;span class=&amp;quot;pl-k&amp;quot;&amp;gt;!&amp;lt;/span&amp;gt;require(&amp;lt;span class=&amp;quot;pl-vo&amp;quot;&amp;gt;tgp&amp;lt;/span&amp;gt;)) install.packages(&amp;lt;span class=&amp;quot;pl-s1&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;pl-pds&amp;quot;&amp;gt;&amp;quot;&amp;lt;/span&amp;gt;tgp&amp;lt;span class=&amp;quot;pl-pds&amp;quot;&amp;gt;&amp;quot;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;) library(&amp;lt;span class=&amp;quot;pl-vo&amp;quot;&amp;gt;tgp&amp;lt;/span&amp;gt;) &amp;lt;span class=&amp;quot;pl-k&amp;quot;&amp;gt;if&amp;lt;/span&amp;gt;(&amp;lt;span class=&amp;quot;pl-k&amp;quot;&amp;gt;!&amp;lt;/span&amp;gt;require(&amp;lt;span class=&amp;quot;pl-vo&amp;quot;&amp;gt;qualV&amp;lt;/span&amp;gt;)) install.packages(&amp;lt;span class=&amp;quot;pl-s1&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;pl-pds&amp;quot;&amp;gt;&amp;quot;&amp;lt;/span&amp;gt;qualV&amp;lt;span class=&amp;quot;pl-pds&amp;quot;&amp;gt;&amp;quot;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;) library(&amp;lt;span class=&amp;quot;pl-vo&amp;quot;&amp;gt;qualV&amp;lt;/span&amp;gt;) &amp;lt;span class=&amp;quot;kr&amp;quot;&amp;gt;if&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;!&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;kn&amp;quot;&amp;gt;require&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt;hydromad&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;))&amp;lt;/span&amp;gt; install.packages&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;s&amp;quot;&amp;gt;&amp;quot;hydromad&amp;quot;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;,&amp;lt;/span&amp;gt;repos&amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;s&amp;quot;&amp;gt;&amp;quot;http://hydromad.catchment.org&amp;quot;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;) library(hydromad) &amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;pl-k&amp;quot;&amp;gt;if&amp;lt;/span&amp;gt;(&amp;lt;span class=&amp;quot;pl-k&amp;quot;&amp;gt;!&amp;lt;/span&amp;gt;require(devtools)) install.packages(&amp;lt;span class=&amp;quot;pl-s1&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;pl-pds&amp;quot;&amp;gt;&amp;quot;devtools&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;pl-pds&amp;quot;&amp;gt;&amp;quot;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;) library(devtools) # install the fuse package directly from GitHub install_github(&amp;lt;span class=&amp;quot;pl-s1&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;pl-pds&amp;quot;&amp;gt;&amp;quot;&amp;lt;/span&amp;gt;ICHydro/r_fuse&amp;lt;span class=&amp;quot;pl-pds&amp;quot;&amp;gt;&amp;quot;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;, &amp;lt;span class=&amp;quot;pl-v&amp;quot;&amp;gt;subdir&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;pl-k&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;pl-s1&amp;quot;&amp;gt;&amp;lt;span class=&amp;quot;pl-pds&amp;quot;&amp;gt;&amp;quot;&amp;lt;/span&amp;gt;fuse&amp;lt;span class=&amp;quot;pl-pds&amp;quot;&amp;gt;&amp;quot;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;) library(&amp;lt;span class=&amp;quot;pl-vo&amp;quot;&amp;gt;fuse&amp;lt;/span&amp;gt;) The functions are named as in RHydro, the only difference is that the list of model structures is now called internally and does not need to be passed as input. It is still compatible with hydromad and below you find few lines to run a test (also available as gist here). # Load sample data&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt; d&amp;lt;/span&amp;gt;ata&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt;DATA&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;) #&amp;lt;/span&amp;gt; Set the parameter ranges hydromad.options&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt;fusesma&amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt;fusesma.ranges&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(),&amp;lt;/span&amp;gt;fuserouting&amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt;fuserouting.ranges&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;()) &amp;lt;/span&amp;gt;# Set model modspec &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;&amp;lt;-&amp;lt;/span&amp;gt; hydromad&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt;DATA&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;, &amp;lt;/span&amp;gt;sma &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;s&amp;quot;&amp;gt;&amp;quot;fusesma&amp;quot;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;, &amp;lt;/span&amp;gt;routing &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;s&amp;quot;&amp;gt;&amp;quot;fuserouting&amp;quot;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;, &amp;lt;/span&amp;gt;mid &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;m&amp;quot;&amp;gt;1&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;:&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;m&amp;quot;&amp;gt;1248&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;, &amp;lt;/span&amp;gt;deltim &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;m&amp;quot;&amp;gt;1&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;) &amp;lt;/span&amp;gt;# Randomly generate 1 parameter set myNewParameterSet &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;&amp;lt;-&amp;lt;/span&amp;gt; parameterSets&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt; coef&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt;modspec&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;,&amp;lt;/span&amp;gt; warn&amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;kc&amp;quot;&amp;gt;FALSE&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;),&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;m&amp;quot;&amp;gt;1&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;,&amp;lt;/span&amp;gt; method&amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;s&amp;quot;&amp;gt;&amp;quot;random&amp;quot;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;) &amp;lt;/span&amp;gt;# Run a simulation using the parameter set generated above modx &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;&amp;lt;-&amp;lt;/span&amp;gt; update&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt;modspec&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;,&amp;lt;/span&amp;gt; newpars &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt; myNewParameterSet&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;) &amp;lt;/span&amp;gt;# Generate a summary of the result &amp;lt;span class=&amp;quot;kp&amp;quot;&amp;gt;summary&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt;modx&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;) &amp;lt;/span&amp;gt;# Plot results hydromad&amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;:::&amp;lt;/span&amp;gt;xyplot.hydromad&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt;modx&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;,&amp;lt;/span&amp;gt; with.P&amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;kc&amp;quot;&amp;gt;TRUE&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;)&amp;lt;/span&amp;gt; I thought a basic benchmark between RHydro and fuse packages would be interesting (here the gist). The result is that fuse&amp;rsquo;s functions seem to run over 145 times faster than the corresponding functions in RHydro. That&amp;rsquo;s a great news if you plan to do anything that requires hundreds/thousands of runs! Here the detailed results of the benchmark: &amp;lt;span class=&amp;quot;GAKS5OJBFCB ace_keyword&amp;quot;&amp;gt;&amp;gt; &amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;GAKS5OJBIBB ace_keyword&amp;quot;&amp;gt;compare &amp;lt;/span&amp;gt;Unit: seconds expr min lq median uq max neval f(DATA, parameters) 423.230827 433.070465 446.845983 451.28512 461.818262 10 g(DATA, parameters) 2.893856 2.988898 3.076531 3.59736 3.713473 10 My session info: &amp;gt; sessionInfo() R version 3.1.1 (2014-07-10) Platform: x86_64-pc-linux-gnu (64-bit) locale: [1] LC_CTYPE=en_GB.UTF-8 LC_NUMERIC=C LC_TIME=en_GB.UTF-8 [4] LC_COLLATE=en_GB.UTF-8 LC_MONETARY=en_GB.UTF-8 LC_MESSAGES=en_GB.UTF-8 [7] LC_PAPER=en_GB.UTF-8 LC_NAME=C LC_ADDRESS=C [10] LC_TELEPHONE=C LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C attached base packages: [1] stats graphics grDevices utils datasets methods base other attached packages: [1] ggplot2_1.0.0 microbenchmark_1.3-0 tgp_2.4-9 fuse_1.1.0 RHydro_2014-04.1 [6] qualV_0.3 KernSmooth_2.23-12 XML_3.98-1.1 deSolve_1.10-9 lhs_0.10 [11] sp_1.0-15 xts_0.9-7 zoo_1.7-11 loaded via a namespace (and not attached): [1] colorspace_1.2-4 digest_0.6.4 grid_3.1.1 gtable_0.1.2 lattice_0.20-29 MASS_7.3-33 [7] munsell_0.4.2 plyr_1.8.1 proto_0.3-10 Rcpp_0.11.2 reshape2_1.4 scales_0.2.4 [13] stringr_0.6.2 tools_3.1.1 Image credits to Nick Chill: http://goo.gl/9vWVEb "
},
{
	"uri": "/2014/07/25/fuse-model-in-rhydro-package-part-4-hydromad-compatibility/",
	"title": "FUSE model in RHydro package (part 4: HydroMAD compatibility)",
	"tags": [],
	"description": "",
	"content": "This is the fourth of a series of tutorials on the FUSE implementation within the RHydro package. The script for this tutorial is available here. If you are interested in following the discussion related to this post and see how it evolves, join the R4Hydrology community on Google+! If you want to know what FUSE is, how to prepare your data and run a simple simulation go to the first post of the series, for a basic calibration example (using 1 model structure) go to the second post, while for an example of multi-model calibration got to the third post. RHydro-HydroMAD compatibility HydroMAD is an excellent framework for hydrological modelling, optimization, sensitivity analysis and assessment of results. It contains a large set of soil moisture accounting modules and routing functions. Thanks to Joseph Guillaume (hydromad&amp;rsquo;s maintainer), FUSE-RHydro is now compatible with HydroMAD, therefore using and calibrating FUSE becomes even easier! Joseph provided many of the examples below, many thanks for that too! In this tutorial I will show how to: set up FUSE and its parameter ranges using the hydromad approach run a simulation calibrate FUSE using one of the hydromad&amp;rsquo;s algorithms Recap from previous posts Load the package and prepare your default list of models library(&amp;quot;hydromad&amp;quot;) library(&amp;quot;RHydro&amp;quot;) data(modlist) Read sample data in: data &amp;lt;- read.csv(&amp;quot;dummyData.csv&amp;quot;) Convert to date the first column and then convert to zoo object temp&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;[,&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;m&amp;quot;&amp;gt;1&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;]&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;&amp;lt;-&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;kp&amp;quot;&amp;gt;as.Date&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt;temp&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;[,&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;m&amp;quot;&amp;gt;1&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;],&amp;lt;/span&amp;gt;format&amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;s&amp;quot;&amp;gt;&amp;quot;%Y-%m-%d&amp;quot;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;) &amp;lt;/span&amp;gt;DATA &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;&amp;lt;-&amp;lt;/span&amp;gt; read.zoo&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt;temp&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;)&amp;lt;/span&amp;gt; Step 1: set up FUSE and its parameter ranges using the hydromad approach HydroMAD allows to specify a rainfall-runoff model of choice. This is achieved by using the hydromad() function and specifying the soil moisture accounting model and routing function to use. Set the parameter ranges using hydromad.options hydromad.options&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt;fusesma &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;= &amp;lt;/span&amp;gt;fusesma.ranges&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(),&amp;lt;/span&amp;gt; fuserouting &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;= &amp;lt;/span&amp;gt;fuserouting.ranges&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;())&amp;lt;/span&amp;gt; Set up the model modspec &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;&amp;lt;-&amp;lt;/span&amp;gt; hydromad&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt;DATA&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;, &amp;lt;/span&amp;gt; sma &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;s&amp;quot;&amp;gt;&amp;quot;fusesma&amp;quot;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;, &amp;lt;/span&amp;gt; routing &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;s&amp;quot;&amp;gt;&amp;quot;fuserouting&amp;quot;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;, &amp;lt;/span&amp;gt; mid &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;m&amp;quot;&amp;gt;1&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;:&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;m&amp;quot;&amp;gt;1248&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;, &amp;lt;/span&amp;gt; modlist &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt; modlist&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;)&amp;lt;/span&amp;gt; Randomly generate 1 parameter set myNewParameterSet &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;&amp;lt;-&amp;lt;/span&amp;gt; parameterSets&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;( &amp;lt;/span&amp;gt;coef&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt;modspec&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;, &amp;lt;/span&amp;gt;warn&amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;kc&amp;quot;&amp;gt;FALSE&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;),&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;m&amp;quot;&amp;gt; 1&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;, &amp;lt;/span&amp;gt; method&amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;s&amp;quot;&amp;gt;&amp;quot;random&amp;quot; &amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;)&amp;lt;/span&amp;gt; Step 2: run a single simulation Run a simulation using the parameter set generated above modx &amp;lt;- update(modspec, newpars = myNewParameterSet) Generate a summary of the result summary(modx) The instantaneous runoff is U &amp;lt;- modx$U The routed discharge is Qrout &amp;lt;- modx$fitted.values Plot the Observed vs Simulated value hydromad:::xyplot.hydromad(modx) Add the precipitation to the above plot hydromad:::xyplot.hydromad(modx, with.P=TRUE) Step 3: calibrate FUSE using one of hydromad&amp;rsquo;s algorithms Hydromad provide the &amp;ldquo;fitBy&amp;rdquo; method to calibrate using a specified algorithm. As an example, the Shuffled Complex Evolution method can be used as shown below. Please note that the procedure is likely to take a LONG time. modfit &amp;lt;- fitBySCE(modspec) Get a summary of the result summary(modfit) If you want to use the latest version of fuse, the above steps can be adapted as follows: library(hydromad) library(fuse) data(modlist) # Load data temp &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;&amp;lt;-&amp;lt;/span&amp;gt; read.csv&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;s&amp;quot;&amp;gt;&amp;quot;dummyData.csv&amp;quot;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;) &amp;lt;/span&amp;gt;temp&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;[,&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;m&amp;quot;&amp;gt;1&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;]&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;&amp;lt;-&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;quot;kp&amp;quot;&amp;gt;as.Date&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt;temp&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;[,&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;m&amp;quot;&amp;gt;1&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;],&amp;lt;/span&amp;gt;format&amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;=&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;s&amp;quot;&amp;gt;&amp;quot;%Y-%m-%d&amp;quot;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;) &amp;lt;/span&amp;gt;DATA &amp;lt;span class=&amp;quot;o&amp;quot;&amp;gt;&amp;lt;-&amp;lt;/span&amp;gt; read.zoo&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;(&amp;lt;/span&amp;gt;temp&amp;lt;span class=&amp;quot;p&amp;quot;&amp;gt;) &amp;lt;/span&amp;gt;# Set the parameter ranges using hydromad.options hydromad.options(fusesma = fusesma.ranges(), fuserouting = fuserouting.ranges()) # Set up the model modspec &amp;lt;- hydromad(DATA, sma = &amp;quot;fusesma&amp;quot;, routing = &amp;quot;fuserouting&amp;quot;, mid = 1:1248, deltim = 1/24) # Calibrate FUSE using one of hydromadâ€™s algorithms modfit &amp;lt;- fitBySCE(modspec) # Get a summary of the result summary(modfit) What&amp;rsquo;s next? This tutorials was just a brief introduction to a topic that can be explored in many different directions. From a technical point of view, it could be worth to invest some effort into code optimization and/or parallelisation. This would also have an impact on the scientific side facilitating experiments on sensitivity analysis, regionalisation of catchment characteristics and model structure variability. Some of those ideas are already on their way, some others are just random thoughts. Therefore&amp;hellip;watch this space! "
},
{
	"uri": "/2014/07/18/fuse-model-in-rhydro-package-part-3-ensemble/",
	"title": "FUSE model in RHydro package (part 3: ensemble)",
	"tags": [],
	"description": "",
	"content": "This is the third of a series of tutorials on the FUSE implementation within the RHydro package. The script for this tutorial is available here. If you are interested in following the discussion related to this post and see how it evolves, join the R4Hydrology community on Google+! If you want to know what FUSE is, how to prepare your data and run a simple simulation go to the first post of the series, while for a basic calibration example (using 1 model structure) go to the second post. Recap from previous posts Load the package and prepare your data: library(RHydro) temp &amp;lt;- read.csv(&amp;quot;dummyData.csv&amp;quot;) DATA &amp;lt;- zooreg(temp[,2:4], order.by=temp[,1]) myDELTIM &amp;lt;- 1 FUSE ensemble Very often hydrologists decide to use a particular hydrological model based on code availability, familiarity and experience rather than based on hydrological suitability. The real advantage of using FUSE is the possibility to work with an ensemble of multiple models so that uncertainties related to the model structure can be quantified. The input that defines the model structure is called mid (model identification number) and its value ranges between 1 and 1248. When the most suitable model structure(s) is not known a priori, the mid can be added to the list of parameters and calibrated. Adding the full mid-range implies the need to increase significantly the sampling space. There are, however, 4 model structures (called parent models) from which all the other model combinations are derived. In this tutorial I will only consider those 4 model structures. In this tutorial I will show how to: define the update sampling space (parameter + mid ranges) run a multi-model calibration compare results Step A: define the parameter ranges + mid range The parent models are as follows: 60 = TOPMODEL 230 = ARNOXVIC 342 = PRMS 426 = SACRAMENTO Therefore mid can be one of those 4 values: mids &amp;lt;- c(60, 230, 342, 426) The parameter ranges are defined as in the previous post. require(tgp) DefaultRanges &amp;lt;- data.frame(rbind(rferr_add = c(0,0), rferr_mlt = c(1,1), maxwatr_1 = c(25,500), maxwatr_2 = c(50,5000), fracten = c(0.05,0.95), frchzne = c(0.05,0.95), fprimqb = c(0.05,0.95), rtfrac1 = c(0.05,0.95), percrte = c(0.01,1000), percexp = c(1,20), sacpmlt = c(1,250), sacpexp = c(1,5), percfrac = c(0.05,0.95), iflwrte = c(0.01,1000), baserte = c(0.001,1000), qb_powr = c(1,10), qb_prms = c(0.001,0.25), qbrate_2a = c(0.001,0.25), qbrate_2b = c(0.001,0.25), sareamax = c(0.05,0.95), axv_bexp = c(0.001,3), loglamb = c(5,10), tishape = c(2,5), timedelay = c(0.01,5))) names(DefaultRanges) &amp;lt;- c(&amp;quot;Min&amp;quot;,&amp;quot;Max&amp;quot;) nRuns &amp;lt;- 100 parameters &amp;lt;- lhs( nRuns, as.matrix(DefaultRanges) ) parameters &amp;lt;- data.frame(parameters) names(parameters) &amp;lt;- c(&amp;quot;rferr_add&amp;quot;,&amp;quot;rferr_mlt&amp;quot;,&amp;quot;maxwatr_1&amp;quot;,&amp;quot;maxwatr_2&amp;quot;,&amp;quot;fracten&amp;quot;,&amp;quot;frchzne&amp;quot;,&amp;quot;fprimqb&amp;quot;,&amp;quot;rtfrac1&amp;quot;,&amp;quot;percrte&amp;quot;,&amp;quot;percexp&amp;quot;,&amp;quot;sacpmlt&amp;quot;,&amp;quot;sacpexp&amp;quot;,&amp;quot;percfrac&amp;quot;,&amp;quot;iflwrte&amp;quot;,&amp;quot;baserte&amp;quot;,&amp;quot;qb_powr&amp;quot;,&amp;quot;qb_prms&amp;quot;,&amp;quot;qbrate_2a&amp;quot;,&amp;quot;qbrate_2b&amp;quot;,&amp;quot;sareamax&amp;quot;,&amp;quot;axv_bexp&amp;quot;,&amp;quot;loglamb&amp;quot;,&amp;quot;tishape&amp;quot;,&amp;quot;timedelay&amp;quot;) Step B: run a multi-model calibration Use the Nash-Sutcliffe efficiency as objective function and run the model 4*nRuns times (for each mid and parameter set). require(qualV) indices &amp;lt;- rep(NA,4*nRuns) discharges &amp;lt;- matrix(NA,ncol=4*nRuns,nrow=dim(DATA)[1]) kCounter &amp;lt;- 0 for (m in 1:4){ myMID &amp;lt;- mids[m] for (pid in 1:nRuns){ kCounter &amp;lt;- kCounter + 1 ParameterSet &amp;lt;- as.list(parameters[pid,]) # Run FUSE Soil Moisture Accounting module Qinst &amp;lt;- fusesma.sim(DATA, mid = myMID, modlist, deltim = myDELTIM, states = FALSE, fluxes = FALSE, fracstate0 = 0.25, ParameterSet$rferr_add, ParameterSet$rferr_mlt, ParameterSet$frchzne, ParameterSet$fracten, ParameterSet$maxwatr_1, ParameterSet$percfrac, ParameterSet$fprimqb, ParameterSet$qbrate_2a, ParameterSet$qbrate_2b, ParameterSet$qb_prms, ParameterSet$maxwatr_2, ParameterSet$baserte, ParameterSet$rtfrac1, ParameterSet$percrte, ParameterSet$percexp, ParameterSet$sacpmlt, ParameterSet$sacpexp, ParameterSet$iflwrte, ParameterSet$axv_bexp, ParameterSet$sareamax, ParameterSet$loglamb, ParameterSet$tishape, ParameterSet$qb_powr) # Run FUSE Routing module Qrout &amp;lt;- fuserouting.sim(Qinst, mid = myMID, modlist = modlist, timedelay = ParameterSet$timedelay, deltim = myDELTIM) indices[kCounter] &amp;lt;- EF(DATA$Q,Qrout) discharges[,kCounter] &amp;lt;- Qrout } } Step C: compare results Deterministically, the best simulation according to the Nash-Sutcliffe efficiency, is the one with the maximum factor. bestRun &amp;lt;- which(indices == max(indices)) This corresponds to the model ARNOXVIC, in fact: bestModel &amp;lt;- function(runNumber){ if (runNumber&amp;lt;(nRuns+1)) myBestModel &amp;lt;- &amp;quot;TOPMODEL&amp;quot; if (runNumber&amp;gt;(nRuns+1) &amp;amp; runNumber&amp;lt;(2*nRuns+1)) myBestModel &amp;lt;- &amp;quot;ARNOXVIC&amp;quot; if (runNumber&amp;gt;(2*nRuns+1) &amp;amp; runNumber&amp;lt;(3*nRuns+1)) myBestModel &amp;lt;- &amp;quot;PRMS&amp;quot; if (runNumber&amp;gt;(3*nRuns+1) &amp;amp; runNumber&amp;lt;(4*nRuns+1)) myBestModel &amp;lt;- &amp;quot;SACRAMENTO&amp;quot; return(myBestModel) } bestModel(bestRun) plot(coredata(DATA$Q),type=&amp;quot;l&amp;quot;,xlab=&amp;quot;&amp;quot;,ylab=&amp;quot;Streamflow [mm/day]&amp;quot;, lwd=0.5) for(pid in 1:(4*nRuns)){ lines(discharges[,pid], col=&amp;quot;gray&amp;quot;, lwd=3) } lines(coredata(DATA$Q),col=&amp;quot;black&amp;quot;, lwd=1) lines(discharges[,bestRun],col=&amp;quot;red&amp;quot;, lwd=1) The plot below shows the observed streamflow in black, all the simulated results in grey and the &amp;ldquo;best&amp;rdquo; simulated streamflow in red. As you can see, using multiple model structures inflates the uncertainty. [caption id=&amp;ldquo;attachment_349&amp;rdquo; align=&amp;ldquo;aligncenter&amp;rdquo; width=&amp;ldquo;300&amp;rdquo;] FUSE simulations (4 models)[/caption] How the best simulation of each model structure compare to each other? bestRun0060 &amp;lt;- which(indices[1:nRuns] == max(indices[1:nRuns])) bestRun0230 &amp;lt;- nRuns + which(indices[(nRuns+1):(2*nRuns)] == max(indices[(nRuns+1):(2*nRuns)])) bestRun0342 &amp;lt;- 2*nRuns + which(indices[(2*nRuns+1):(3*nRuns)] == max(indices[(2*nRuns+1):(3*nRuns)])) bestRun0426 &amp;lt;- 3*nRuns + which(indices[(3*nRuns+1):(4*nRuns)] == max(indices[(3*nRuns+1):(4*nRuns)])) plot(coredata(DATA$Q),type=&amp;quot;l&amp;quot;,xlab=&amp;quot;&amp;quot;,ylab=&amp;quot;Streamflow [mm/day]&amp;quot;, lwd=1) lines(discharges[,bestRun0060], col=&amp;quot;green&amp;quot;, lwd=1) lines(discharges[,bestRun0230], col=&amp;quot;blue&amp;quot;, lwd=1) lines(discharges[,bestRun0342], col=&amp;quot;pink&amp;quot;, lwd=1) lines(discharges[,bestRun0426], col=&amp;quot;orange&amp;quot;, lwd=1) legend(&amp;quot;top&amp;quot;, c(&amp;quot;TOPMODEL&amp;quot;, &amp;quot;ARNOXVIC&amp;quot;, &amp;quot;PRMS&amp;quot;,&amp;quot;SACRAMENTO&amp;quot;), col = c(&amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;pink&amp;quot;, &amp;quot;orange&amp;quot;), lty = c(1, 1, 1, 1)) [caption id=&amp;ldquo;attachment_350&amp;rdquo; align=&amp;ldquo;aligncenter&amp;rdquo; width=&amp;ldquo;412&amp;rdquo;] Best simulation for each model structure[/caption] The plot above shows that TOPMODEL seems the least affected by the initial conditions, while PRMS is the most affected. What&amp;rsquo;s next? FUSE-RHydro is also compatible with HydroMAD, therefore model calibration and assessment becomes even easier (see an example here)! "
},
{
	"uri": "/2014/07/17/fuse-model-in-rhydro-package-part-2-calibration/",
	"title": "FUSE model in RHydro package (part 2: calibration)",
	"tags": [],
	"description": "",
	"content": "This is the second of a series of tutorials on the FUSE implementation within the RHydro package. The script for this tutorial is available here. If you are interested in following the discussion related to this post and see how it evolves, join the R4Hydrology community on Google+! If you want to know what FUSE is, how to prepare your data and run a simple simulation go to my previous post. Recap from previous post Load the package, prepare your data (dummyData.csv is available here) and select a model structure: library(RHydro) temp &amp;lt;- read.csv(&amp;quot;dummyData.csv&amp;quot;) DATA &amp;lt;- zooreg(temp[,2:4], order.by=temp[,1]) myDELTIM &amp;lt;- 1 myMID &amp;lt;- 60 Sample parameter space using the Latin Hypercube Sampling method The default parameter ranges are suggested in Clark et al. (2008) and are used to sample parameter sets. Define sample domain (min and max for each parameter) DefaultRanges &amp;lt;- data.frame(rbind(rferr_add = c(0,0), # additive rainfall error (mm) rferr_mlt = c(1,1), # multiplicative rainfall error (-) maxwatr_1 = c(25,500), # depth of the upper soil layer (mm) maxwatr_2 = c(50,5000), # depth of the lower soil layer (mm) fracten = c(0.05,0.95), # fraction total storage in tension storage (-) frchzne = c(0.05,0.95), # fraction tension storage in recharge zone (-) fprimqb = c(0.05,0.95), # fraction storage in 1st baseflow reservoir (-) rtfrac1 = c(0.05,0.95), # fraction of roots in the upper layer (-) percrte = c(0.01,1000), # percolation rate (mm day-1) percexp = c(1,20), # percolation exponent (-) sacpmlt = c(1,250), # SAC model percltn mult for dry soil layer (-) sacpexp = c(1,5), # SAC model percltn exp for dry soil layer (-) percfrac = c(0.05,0.95), # fraction of percltn to tension storage (-) iflwrte = c(0.01,1000), # interflow rate (mm day-1) baserte = c(0.001,1000), # baseflow rate (mm day-1) qb_powr = c(1,10), # baseflow exponent (-) qb_prms = c(0.001,0.25), # baseflow depletion rate (day-1) qbrate_2a = c(0.001,0.25), # baseflow depletion rate 1st reservoir (day-1) qbrate_2b = c(0.001,0.25), # baseflow depletion rate 2nd reservoir (day-1) sareamax = c(0.05,0.95), # maximum saturated area (-) axv_bexp = c(0.001,3), # ARNO/VIC b exponent (-) loglamb = c(5,10), # mean value of the topographic index (m) tishape = c(2,5), # shape param for the topo index Gamma dist (-) timedelay = c(0.01,5) )) # time delay in runoff (days) names(DefaultRanges) &amp;lt;- c(&amp;quot;Min&amp;quot;,&amp;quot;Max&amp;quot;) Sample from the above ranges using the Latin Hypercube Sampling method. require(tgp) nRuns &amp;lt;- 100 # this is the number of samples parameters &amp;lt;- lhs( nRuns, as.matrix(DefaultRanges) ) parameters &amp;lt;- data.frame(parameters) names(parameters) &amp;lt;- c(&amp;quot;rferr_add&amp;quot;,&amp;quot;rferr_mlt&amp;quot;,&amp;quot;maxwatr_1&amp;quot;,&amp;quot;maxwatr_2&amp;quot;,&amp;quot;fracten&amp;quot;,&amp;quot;frchzne&amp;quot;,&amp;quot;fprimqb&amp;quot;,&amp;quot;rtfrac1&amp;quot;,&amp;quot;percrte&amp;quot;,&amp;quot;percexp&amp;quot;,&amp;quot;sacpmlt&amp;quot;,&amp;quot;sacpexp&amp;quot;,&amp;quot;percfrac&amp;quot;,&amp;quot;iflwrte&amp;quot;,&amp;quot;baserte&amp;quot;,&amp;quot;qb_powr&amp;quot;,&amp;quot;qb_prms&amp;quot;,&amp;quot;qbrate_2a&amp;quot;,&amp;quot;qbrate_2b&amp;quot;,&amp;quot;sareamax&amp;quot;,&amp;quot;axv_bexp&amp;quot;,&amp;quot;loglamb&amp;quot;,&amp;quot;tishape&amp;quot;,&amp;quot;timedelay&amp;quot;) Run simulations Use the Nash-Sutcliffe efficiency as objective function and run the model nRuns times (1 for each parameter set). require(qualV) indices &amp;lt;- rep(NA,nRuns) discharges &amp;lt;- matrix(NA,ncol=nRuns,nrow=dim(DATA)[1]) for (pid in 1:nRuns){ ParameterSet &amp;lt;- as.list(parameters[pid,]) # Run FUSE Soil Moisture Accounting module Qinst &amp;lt;- fusesma.sim(DATA, mid = myMID, modlist, deltim = myDELTIM, states = FALSE, fluxes = FALSE, fracstate0 = 0.25, ParameterSet$rferr_add, ParameterSet$rferr_mlt, ParameterSet$frchzne, ParameterSet$fracten, ParameterSet$maxwatr_1, ParameterSet$percfrac, ParameterSet$fprimqb, ParameterSet$qbrate_2a, ParameterSet$qbrate_2b, ParameterSet$qb_prms, ParameterSet$maxwatr_2, ParameterSet$baserte, ParameterSet$rtfrac1, ParameterSet$percrte, ParameterSet$percexp, ParameterSet$sacpmlt, ParameterSet$sacpexp, ParameterSet$iflwrte, ParameterSet$axv_bexp, ParameterSet$sareamax, ParameterSet$loglamb, ParameterSet$tishape, ParameterSet$qb_powr) # Run FUSE Routing module Qrout &amp;lt;- fuserouting.sim(Qinst, mid = myMID, modlist = modlist, timedelay = ParameterSet$timedelay, deltim = myDELTIM) indices[pid] &amp;lt;- EF(DATA$Q,Qrout) discharges[,pid] &amp;lt;- Qrout } Plot the best simulation Deterministically, the best simulation according to the Nash-Sutcliffe efficiency, is the one with the maximum factor. bestRun &amp;lt;- which(indices == max(indices))[1] # this takes only the first simulation if more than one return the same efficiency value plot(coredata(DATA$Q),type=&amp;quot;l&amp;quot;,xlab=&amp;quot;&amp;quot;,ylab=&amp;quot;Streamflow [mm/day]&amp;quot;, lwd=0.5) for(pid in 1:nRuns){ lines(discharges[,pid], col=&amp;quot;gray&amp;quot;, lwd=3) } lines(coredata(DATA$Q),col=&amp;quot;black&amp;quot;, lwd=1) lines(discharges[,bestRun],col=&amp;quot;red&amp;quot;, lwd=1) The plot below shows the observed streamflow in black, all the simulated results in grey and the &amp;ldquo;best&amp;rdquo; simulated streamflow in red. [caption id=&amp;ldquo;attachment_329&amp;rdquo; align=&amp;ldquo;aligncenter&amp;rdquo; width=&amp;ldquo;393&amp;rdquo;] Results FUSE basic calibration[/caption] What&amp;rsquo;s next? The real advantage of using FUSE is the possibility to work with an ensemble of multiple models (see an example here). FUSE-RHydro is also compatible with HydroMAD, therefore model calibration and assessment becomes even easier (see an example here)! "
},
{
	"uri": "/2014/07/16/fuse-model-in-rhydro-package-part-1-simple-simulation/",
	"title": "FUSE model in RHydro package (part 1: simple simulation)",
	"tags": [],
	"description": "",
	"content": "This is the first of a series of tutorials on the FUSE implementation within the RHydro package. The script for this tutorial is available here. If you are interested in following the discussion related to this post and see how it evolves, join the R4Hydrology community on Google+! What&amp;rsquo;s FUSE? FUSE is an ensemble of numerous conceptual rainfall-runoff models developed byClark et al. (2008) and used to simulate the streamflow discharge for a river catchment when areal averaged time series of precipitation (plus snowmelt) and evapotranspiration are available. The code was originally developed by Martyn Clark in Fortran, but a couple of years ago I implemented a version of the same code in R. The code is part of the RHydro package available from R-Forge. In this tutorial I&amp;rsquo;m going to show how to: install RHydro, prepare data for FUSE, run a simulation. Step A: install RHydro RHydro is available from R-Forge and can beinstalled running the following command: install.packages(&amp;quot;RHydro&amp;quot;, repos = &amp;quot;http://R-Forge.R-project.org&amp;quot;) Step B: prepare your data Prepare your data so that you have a zooreg object containing valid dates, P (precipitation+snowmelt time series), E (potential evapotranspiration time series) and Q (streamflow discharge time series). If you do not know how to do this, download my dummy data from here and adapt the content. [caption id=&amp;ldquo;attachment_301&amp;rdquo; align=&amp;ldquo;aligncenter&amp;rdquo; width=&amp;ldquo;223&amp;rdquo;] Screenshot of dummyData.csv[/caption] Save dummyData.csv in your working directory. Now, load important libraries and create the zooreg object. # Load libraries library(RHydro) # Load data into a zooreg object temp &amp;lt;- read.csv(&amp;quot;dummyData.csv&amp;quot;) DATA &amp;lt;- zooreg(temp[,2:4], order.by=temp[,1]) Step C: run a simulation FUSE contains 1248 different model structures. If you want to use only one of them, you should specify the relative model identification number (mid). Let&amp;rsquo;s assume that: you want to run the model that corresponds to mid = 60, you want to use a specific set of parameters, you data is made of daily time series. Then, you define the model inputs as in the example below: # (1) myMID &amp;lt;- 60 # (2) myParameterSet &amp;lt;- list(rferr_add = 0, rferr_mlt = 1, frchzne = 0.5, fracten = 0.6828, maxwatr_1 = 106.6406, percfrac = 0.5, fprimqb = 0.5, qbrate_2a = 0.025, qbrate_2b = 0.01, qb_prms = 0.1294, maxwatr_2 = 3839.8, baserte = 50, rtfrac1 = 0.75, percrte = 703.128, percexp = 4.8594, sacpmlt = 10, sacpexp = 5, iflwrte = 500, axv_bexp = 0.7039, sareamax = 0.25, loglamb = 7.5, tishape = 3, qb_powr = 5, timedelay = 1.3355) # (3) myDELTIM &amp;lt;- 1 You can calculate the effective rainfall as follows: Qinst &amp;lt;- fusesma.sim (DATA, mid = myMID, modlist, deltim = myDELTIM, states = FALSE, fluxes = FALSE, fracstate0 = 0.25, myParameterSet$rferr_add, myParameterSet$rferr_mlt, myParameterSet$frchzne, myParameterSet$fracten, myParameterSet$maxwatr_1, myParameterSet$percfrac, myParameterSet$fprimqb, myParameterSet$qbrate_2a, myParameterSet$qbrate_2b, myParameterSet$qb_prms, myParameterSet$maxwatr_2, myParameterSet$baserte, myParameterSet$rtfrac1, myParameterSet$percrte, myParameterSet$percexp, myParameterSet$sacpmlt, myParameterSet$sacpexp, myParameterSet$iflwrte, myParameterSet$axv_bexp, myParameterSet$sareamax, myParameterSet$loglamb, myParameterSet$tishape, myParameterSet$qb_powr) Now calculate the routed runoff: Qrout &amp;lt;- fuserouting.sim(Qinst, mid = myMID, modlist = modlist, timedelay = myParameterSet$timedelay, deltim = myDELTIM) Plot the routed discharge: plot(Qrout, type = &amp;quot;l&amp;quot;) If you are using my dummy data, the result of the last command should be as in the figure below. [caption id=&amp;ldquo;attachment_304&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;300&amp;rdquo;] Routed streamflow discharge[/caption] The input fracstate0 (see fusesma function) refers to the initial conditions. The default value is 0.25 which means that at time = 0 the water storages already contain 25% of their maximum capacity. You can change this value to see how a variation of fracstate0 may affect the result of your simulation. What&amp;rsquo;s next? This tutorial assumes you want to use 1 model structure and 1 parameter set. which is a rather simplistic case. The majority of the time hydrologists might be interested in calibrating one specific model structure (see an example here). However, the real advantage of using FUSE is the possibility to work with an ensemble of multiple models (see an example here). FUSE-RHydro is also compatible with HydroMAD, therefore model calibration and assessment becomes even easier (see an example here)! "
},
{
	"uri": "/2013/07/03/high-performance-computing-service---part-3-transfer-your-files/",
	"title": "High Performance Computing Service - Part 3: Transfer your files",
	"tags": [],
	"description": "",
	"content": "At this stage, all the files are ready. Now, let&amp;rsquo;s organize the stores adding subdirectories then transfer the files from my desktop computer to the HPC server. ON THE HPC: I have organized the stores in this way: mkdir $HOME/R #for custom library mkdir $HOME/scripts mkdir $HOME/R/scripts/r #for my R scripts mkdir $WORK/inputs mkdir $WORK/outputs mkdir $WORK/outputs/Rdata mkdir $WORK/outputs/Rout FROM MY DESKTOP: transfer the files created in Part 2 to the HPC server. scp topmodel.tar.gz login.cx1.hpc.ic.ac.uk:$HOME/R #to install R packages (e.g. fuse) move the tarball to HPC scp batch.sh login.cx1.hpc.ic.ac.uk:$HOME/ #script to set up the runs scp fuse_1.0.tar.gz login.cx1.hpc.ic.ac.uk:$HOME/scripts #to install R packages (e.g. fuse) move the tarball to HPC INSTALL PACKAGES AND ANY OTHER APPLICATION IT MAY BE NEEDED module load R/2.15 intel-suite/2012 R CMD INSTALL $HOME/R/fuse_1.0.tar.gz #install the package # (alternatively, you can download it from cran) ON THE HPC: RUN THE BATCH FILE qsub batch.sh For examples of the above mentioned files, see PART 2. For information on using the HPC service see http://www.hpc.ic.ac.uk "
},
{
	"uri": "/2013/07/02/high-performance-computing-service---part-2-get-your-files-ready/",
	"title": "High Performance Computing Service - Part 2: Get your files ready",
	"tags": [],
	"description": "",
	"content": "To use the HPC service I need: input files (e.g. data.rda) some routines (e.g. myroutine1.R, myroutine2.R, myroutine3.R) a batch script The input files are: data_C1.rda data_C2.rda data_C3.rda Each of the above contains the following objects: Classes of Topographic Index (topidxclasses), Delay function (delay), Precipitation time series (rain), Evapotranspiration time series (ET0), Observed streamflow discharge time series (Qobs). For more info on the above input files, read help file of topmodel package (?topmodel) Let&amp;rsquo;s prepare the R routines: myroutine1.R # This routine runs an hydrological model called &amp;quot;topmodel&amp;quot; 1000 times using parameter sets # randomly sampled from a uniform distribution, using data from catchment &amp;quot;C1&amp;quot;. # The result is a vector containing Nash-Sutcliffe efficiencies. library(Hmisc) library(topmodel) load(&amp;quot;$WORK/input/data_C1.rda&amp;quot;) runs &amp;lt;- 10000 vch &amp;lt;- 1000 dt &amp;lt;- 1 Srmax &amp;lt;- runif(runs, min=0, max=2) td &amp;lt;- runif(runs, min=0, max=3) k0 &amp;lt;- runif(runs, min=0, max=0.01) CD &amp;lt;- runif(runs, min=0, max=5) qs0 &amp;lt;- runif(runs, min=3e-5, max=5e-5) lnTe &amp;lt;- runif(runs, min=-4, max=0) m &amp;lt;- runif(runs, min=0, max=0.2) Sr0 &amp;lt;- runif(runs, min=0, max=0.02) vr &amp;lt;- runif(runs, min=100, max=1500) param.set&amp;lt;-cbind(qs0,lnTe,m,Sr0,Srmax,td,vch,vr,k0,CD,dt) # returns an array of (runs) Nash Sutcliffe efficiencies; one for each parameter set: eff1&amp;lt;-topmodel(param.set, topidxclasses, delay, rain, ET0, Qobs = Qobs) myroutine2.R # This routine runs an hydrological model called &amp;quot;topmodel&amp;quot; 1000 times using parameter sets # randomly sampled from a uniform distribution, using data from catchment &amp;quot;C2&amp;quot;. # The result is a vector containing Nash-Sutcliffe efficiencies. library(Hmisc) library(topmodel) load(&amp;quot;$WORK/input/data_C2.rda&amp;quot;) runs &amp;lt;- 10000 vch &amp;lt;- 1000 dt &amp;lt;- 1 Srmax &amp;lt;- runif(runs, min=0, max=2) td &amp;lt;- runif(runs, min=0, max=3) k0 &amp;lt;- runif(runs, min=0, max=0.01) CD &amp;lt;- runif(runs, min=0, max=5) qs0 &amp;lt;- runif(runs, min=3e-5, max=5e-5) lnTe &amp;lt;- runif(runs, min=-4, max=0) m &amp;lt;- runif(runs, min=0, max=0.2) Sr0 &amp;lt;- runif(runs, min=0, max=0.02) vr &amp;lt;- runif(runs, min=100, max=1500) param.set&amp;lt;-cbind(qs0,lnTe,m,Sr0,Srmax,td,vch,vr,k0,CD,dt) # returns an array of (runs) Nash Sutcliffe efficiencies; one for each parameter set: eff2 &amp;lt;- topmodel(param.set, topidxclasses, delay, rain, ET0, Qobs = Qobs) myroutine3.R # This routine runs an hydrological model called &amp;quot;topmodel&amp;quot; 1000 times using parameter sets # randomly sampled from a uniform distribution, using data from catchment &amp;quot;C3&amp;quot;. # The result is a vector containing Nash-Sutcliffe efficiencies. library(Hmisc) library(topmodel) load(&amp;quot;$WORK/input/data_C3.rda&amp;quot;) runs &amp;lt;- 10000 vch &amp;lt;- 1000 dt &amp;lt;- 1 Srmax &amp;lt;- runif(runs, min=0, max=2) td &amp;lt;- runif(runs, min=0, max=3) k0 &amp;lt;- runif(runs, min=0, max=0.01) CD &amp;lt;- runif(runs, min=0, max=5) qs0 &amp;lt;- runif(runs, min=3e-5, max=5e-5) lnTe &amp;lt;- runif(runs, min=-4, max=0) m &amp;lt;- runif(runs, min=0, max=0.2) Sr0 &amp;lt;- runif(runs, min=0, max=0.02) vr &amp;lt;- runif(runs, min=100, max=1500) param.set&amp;lt;-cbind(qs0,lnTe,m,Sr0,Srmax,td,vch,vr,k0,CD,dt) # returns an array of (runs) Nash Sutcliffe efficiencies; one for each parameter set: eff3 &amp;lt;- topmodel(param.set, topidxclasses, delay, rain, ET0, Qobs = Qobs) Let&amp;rsquo;s prepare the batch file: The batch file contains the following important information: the maximum expected running time (walltime, on the second line) the number of cpus to utilize for each job (cpus, on the third line) the memory to allocate for the job (mem, on the third line) the module to use (I&amp;rsquo;ll use the module that access the R version 2.15, fourth line) the list of routines to call and files where to read any printed message (e.g. error messages) batch.sh #!/bin/sh #PBS -l walltime=50:00:00 #PBS -l select=1:ncpus=1:mem=600mb module load R/2.15 intel-suite/2012 R CMD BATCH --slave $HOME/myroutine_C1.R $WORK/outputs/Rout/C1.Rout R CMD BATCH --slave $HOME/myroutine_C2.R $WORK/outputs/Rout/C2.Rout R CMD BATCH --slave $HOME/myroutine_C3.R $WORK/outputs/Rout/C3.Rout Now go to Part 3 to learn how to transfer your files and run jobs. "
},
{
	"uri": "/2012/09/14/ssh-without-password/",
	"title": "SSH without password",
	"tags": [],
	"description": "",
	"content": "Bored of typing a password to access your remote desktop? Use a key! Let&amp;rsquo;s say you are user1 and are using machineA. You want to access machineB as user2. Generate key pairs: user1@machineA:~&amp;gt;ssh-keygen -t rsa user1@machineA:~&amp;gt; ssh user2@machineB mkdir -p .ssh enter user2@machineB&#39;s password: user1@machineA:~&amp;gt; cat .ssh/id_rsa.pub | ssh user2@machineB &#39;cat &amp;gt;&amp;gt; .ssh/authorized_keys&#39; If the ssh port is not the standard 22 and you use ip address rather than hostname user1@machineA:~&amp;gt; cat .ssh/id_rsa.pub | ssh &amp;lt;strong&amp;gt;-p 0000 user2@ip.address&amp;lt;/strong&amp;gt; &#39;cat &amp;gt;&amp;gt; .ssh/authorized_keys&#39; enter user2@machineB&#39;s password: (one last time, I promise!) user1@machineA:~&amp;gt; ssh user2@machineB hostname or ssh &amp;lt;strong&amp;gt;-p 0000 user2@ip.address &amp;lt;/strong&amp;gt; More info here "
},
{
	"uri": "/2012/09/13/set-up-and-test-pywps-using-curl/",
	"title": "Set up and test PyWPS using curl",
	"tags": [],
	"description": "",
	"content": "Install curl to test the service from terminal. &amp;lt;code&amp;gt;sudo aptitude install libcurl3 &amp;lt;/code&amp;gt; Here are some example requests (from terminal): curl &amp;quot;http://localhost/pywps/pywps.cgi?service=wps&amp;amp;version=1.0.0&amp;amp;request=getcapabilities&amp;quot; curl &amp;quot;http://localhost/pywps/pywps.cgi?service=wps&amp;amp;version=1.0.0&amp;amp;request=describeprocess &amp;amp;identifier=dummyprocess&amp;quot; curl &amp;quot;http://localhost/pywps/pywps.cgi?service=wps&amp;amp;version=1.0.0&amp;amp;request=execute &amp;amp;identifier=dummyprocess&amp;amp;datainputs=\[input1=10;input2=10\]&amp;quot; "
},
{
	"uri": "/2012/07/19/high-performance-computing-service---part-1-intro/",
	"title": "High Performance Computing Service - Part 1: Intro",
	"tags": [],
	"description": "",
	"content": "Imperial College London, as many other universities, provides an excellent High Performance Computing Service for its staff and students. It&amp;rsquo;s like a private cloud, with thousands of processors, which allows you to run highly demanding computational jobs. HPC service is particularly suitable for code which can be parallelised. There are many modules and libraries installed and you can use your own routines if written in a common programming/scripting language. For instance I used my R code. Here is a short tutorial on how to use HPC service. I first contacted the HPC Service Manager to activate an account with login credentials matching the college&amp;rsquo;s ones (e.g. my username is &amp;ldquo;user&amp;rdquo;). Once the account is active, the system automatically creates a key pair to easily remote access (for more info read my previous post here) and the following file stores become available: $HOME = /home/user (10GB and is intended for storing binaries, source and modest amounts of data) $WORK = /work/user (at least 150GB which is intended for staging files between jobs and for long term data storage) $TMPDIR = /tmp (to use only for temporary results) Refer to them using environmental variables. Next steps: to prepare the scripts I&amp;rsquo;ll use to run my computations (more info on Part 2). copy on the server the necessary input files, scripts and R packages, if not available online (see Part 3). "
},
{
	"uri": "/2012/07/10/rd-files-error-non-ascii-input-and-no-declared-encoding/",
	"title": "Rd-files error: non-ASCII input and no declared encoding",
	"tags": [],
	"description": "",
	"content": "This error has been annoying me for a while now&amp;hellip;and here is the simplest solution ever!. In R, type: tools::showNonASCII(readLines(&amp;quot;path/filename&amp;quot;)) "
},
{
	"uri": "/2012/07/09/r-cmd-check-tells-me-no-visible-binding-for-global-variable/",
	"title": "R CMD check tells me &#39;no visible binding for global variable&#39;",
	"tags": [],
	"description": "",
	"content": "Today is definitely a lucky day! Here is the solution to avoid the NOTE &amp;lsquo;no visible binding for global variable&amp;rsquo; when running R CMD check. Basically just add to the DESCRIPTION file of your package the following line (for instance after defining the license) LazyData: yes and add a line in the routine which calls the data.frame e.g. DATA P &amp;lt;- DATA[,&amp;quot;P&amp;quot;] E &amp;lt;- DATA[,&amp;quot;E&amp;quot;] In my case, that made the package checker happy! Here is also an alternative solution. "
},
{
	"uri": "/2012/07/07/writing-tables-into-a-postgresql-database-using-r/",
	"title": "Writing tables into a PostgreSQL database using R",
	"tags": [],
	"description": "",
	"content": "If you are using a PostgreSQL database to store your data and R to process it, then you may want to access and edit your DB directly from R. This is possible using a package called &amp;ldquo;RPostgreSQL&amp;rdquo; available from CRAN. Start R in a console: R Then install and load the RPostgreSQL library: install.packages(&amp;quot;RPostgreSQL&amp;quot;) library(&amp;quot;RPostgreSQL&amp;quot;) Choose the driver drv &amp;lt;- dbDriver(&amp;quot;PostgreSQL&amp;quot;) Connect to your database (I assume the database already exists on the localhost) con &amp;lt;- dbConnect(drv, host=&amp;quot;localhost&amp;quot;, user= &amp;quot;exampleuser&amp;quot;, password=&amp;quot;examplepassword&amp;quot;, dbname=&amp;quot;exampledb&amp;quot;) Specify the schema you want to write to (optional, by default it writes in the public shema) dbGetQuery(con, &amp;quot;SET search_path TO exampleschema&amp;quot;) Load the table from a csv (1) or an existing R archive (2): # Option 1 x &amp;lt;- data.frame(read.table(&amp;quot;/home/user/table.csv&amp;quot;,sep=&amp;quot;,&amp;quot;,header=TRUE)) # Option 2 load(&amp;quot;/home/user/table.rda&amp;quot;) x &amp;lt;- data.frame(table) Delete any existing table with the same name: if(dbExistsTable(con,&amp;quot;table1&amp;quot;)) {dbRemoveTable(con,&amp;quot;table1&amp;quot;)} Finally write a new table: dbWriteTable(con,&amp;quot;table1&amp;quot;, x) More details here. "
},
{
	"uri": "/2012/07/06/upgrade-r/",
	"title": "Upgrade R",
	"tags": [],
	"description": "",
	"content": "I&amp;rsquo;m using Ubuntu Oneiric and R 2.13 (check your version using the command: lsb_release -a). Now I need to upgrade R to the latest version to be able to install the package lhs. In the file: sudo nano /etc/apt/sources.list I added the line: deb http://cran.ma.imperial.ac.uk/bin/linux/ubuntu oneiric/ (here the complete list of cran mirrors) and saved it. Then in terminal: sudo apt-get update sudo apt-get install r-base sudo apt-get install r-base-dev The first time you install a package in R 2.15, it asks: &amp;ldquo;Would you like to use a personal library?&amp;rdquo;, type y and then just copy all the packages from ~/R/x86_64-pc-linux-gnu-library/2.13 to ~/R/x86_64-pc-linux-gnu-library/2.15. "
},
{
	"uri": "/2012/07/05/remote-access-to-aws-instance/",
	"title": "Remote access to AWS instance",
	"tags": [],
	"description": "",
	"content": "If you need help to set up an AWS instance, read my previous post. From the navigation menu of your Amazon EC2 console, click on INSTANCES. [caption id=&amp;ldquo;attachment_21&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;300&amp;rdquo;] AWS Console[/caption] Tick the box to select the new instance and take a note of the web server&amp;rsquo;s address, e.g. ec2-00-000-00-000.eu-west-1.compute.amazonaws.com. [caption id=&amp;ldquo;attachment_22&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;300&amp;rdquo;] Choose the instance[/caption] Now go to terminal and type (I assume you are familiar with Secure SHell): ssh -i ~/.ssh/webserverkey.pem ubuntu@ec2-00-000-00-000.eu-west-1.compute.amazonaws.com (you should avoid to access an instance as root, for this reason the user &amp;ldquo;ubuntu&amp;rdquo; is automatically created). If your terminal looks like the one below&amp;hellip; well done! You successfully accessed your instance! [caption id=&amp;ldquo;attachment_26&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;300&amp;rdquo;] Access through terminal[/caption] You can also send files from your computer to the instance using Secury CoPy (scp), which syntax is exactly the same as ssh. Imagine you want to transfer a text file called &amp;ldquo;test.txt&amp;rdquo; from your computer (user home folder, ~) to the amazon instance (ubuntu home folder, /home/ubuntu). Then go to terminal and type: scp -i ~/.ssh/webserverkey.pem ~/test.txt ubuntu@ec2-00-000-00-000.eu-west-1.compute.amazonaws.com:/home/ubuntu/ That&amp;rsquo;s all! More info here "
},
{
	"uri": "/2012/07/04/set-up-an-amazon-web-service-aws-free-usage-tier/",
	"title": "Set up an Amazon Web Service (AWS) Free Usage Tier",
	"tags": [],
	"description": "",
	"content": "Amazon allows you to use a computer in the cloud for free (for 1 year). To have a go, visit http://aws.amazon.com/free/ sign up then log in. This is your AWS Management Console: [caption id=&amp;ldquo;attachment_8&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;300&amp;rdquo;] AWS Management Console[/caption] Click on EC2 and follow the instructions to launch a virtual server, also called Amazon Elastic Compute Cloud (Amazon EC2) instance. [caption id=&amp;ldquo;attachment_9&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;300&amp;rdquo;] Create a new instance[/caption] Just to make things easier, choose the &amp;ldquo;Quick Launch Wizard&amp;rdquo;, choose a name for your instance and create a new key pair. Download the key (e.g. webserverkey.pem) and save it in a folder, e.g. ~/.ssh. To ensure the user can read the key, go to terminal and type: sudo chmod 400 ~/.ssh/webserverkey.pem. Then choose a launch configuration, e.g. Ubuntu Server 12.04 LTS - 64 bit and click CONTINUE. [caption id=&amp;ldquo;attachment_11&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;300&amp;rdquo;] Choose the instance[/caption] Now you can either edit the details of the newly created instance or launch it. [caption id=&amp;ldquo;attachment_13&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;300&amp;rdquo;] Details of the instance[/caption] When ready, click on LAUNCH then CLOSE. [caption id=&amp;ldquo;attachment_14&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;300&amp;rdquo;] The instance is ready[/caption] You will be automatically redirected to you AWS Management Console which now shows the new instance in the section &amp;ldquo;My Resources&amp;rdquo;. If it doesn&amp;rsquo;t, just click on REFRESH. [caption id=&amp;ldquo;attachment_15&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;300&amp;rdquo;] Console[/caption] Your instance is ready to use! To stop or terminate a running instance see read this: http://support.rightscale.com/06-FAQs/FAQ_0149_-_What%27s_the_difference_between_Terminating_and_Stopping_an_EC2_Instance%3F "
},
{
	"uri": "/2012/07/03/r-forge-projects-and-the-svn-repository/",
	"title": "R-Forge projects and the svn repository",
	"tags": [],
	"description": "",
	"content": "R projects available from R-Forge are version controlled using subversion (also known as svn). You can check out any repository using the &amp;ldquo;Anonymous Subversion Access&amp;rdquo;, in terminal: svn checkout svn://svn.r-forge.r-project.org/svnroot/projectname/ Each project may contain many packages (each in a separate folder). To install a package in R, go to terminal and type: cd ~/projectname/pkg R CMD check packagename If there are no errors, you can install the package: R CMD INSTALL packagename To build the package tarball: R CMD build packagename If you make a change to the code and want to add your contribution to the repository, you should contact one of the administrators of the package to be added to the list of developers. Once you have your own developer account you can commit your changes in this way: check out the last copy of the package using the Developer Subversion Access via SSH: svn checkout svn+ssh://_developername_@svn.r-forge.r-project.org/svnroot/projectname/ go to the directory containing the project (e.g. cd ~/projectname) type svn status (you get a list of the files you have added (?) or deleted (!) in your copy) to apply the same changes to the repo, type: svn add path/example.R or svn delete path/example.R once you have done this or if you have simply modified existing file, then you are ready to commit: svn commit. "
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/categories/hugo/",
	"title": "Hugo",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/post/",
	"title": "Posts",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/project/",
	"title": "Projects",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/categories/r/",
	"title": "R",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/talk/",
	"title": "Talks",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/categories/wordpress/",
	"title": "Wordpress",
	"tags": [],
	"description": "",
	"content": ""
}]